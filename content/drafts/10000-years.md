---
title: "Tweeting for 10,000 Years: An Experiment in
  Autonomous Software"
published_at: 2018-06-18T15:35:11Z
location: San Francisco
hook: TODO
---

Deep inside a Texas mountain, a clock is being built.
Unlike other clocks, this one is designed for longevity on
a scale that's incomprehensible to the designers of similar
apparatuses. The counterweight for its drive mechanism is
housed in a hollowed out shaft that's 500 feet high and 12
feet in diameter and weighs an unbelievable 10,000 pounds.
The periodic chimes it plays are controlled by 20 huge
horizontal gears, each of which is 8 feet in diameter. Its
timing is controlled by a 6-foot pendulum assembly
terminating with football-sized titanium weights. It swings
as unhurriedly as one might imagine, taking a full ten
seconds to move back and forth. Components have been
machined to within tolerances of a fraction of an inch,
rather than thousandths, so that they'll keep working
despite inevitable entropic damage caused by the likes of
expansion and rust.

TODO: Picture of mechanism.

If all goes well, the clock will keep time for 10,000
years. It's called "[Clock of the Long Now][clock]", and is
a project of the [Long Now Foundation][longnow], who aim to
provide a counterpoint to today's accelerating trend
towards an ever shortening attention span in society by
fostering long-term planning and responsibility. They
consider long thinking to be on the centuries scale and
beyond, and their aim is to to construct frameworks that
will be functional for 10,000 years. As a reminder of this
charter, the Long Now represents years in five digits
instead of four -- to them, it's the year 02018.

## The walkaway test (#walkaway-test)

Software isn't as well suited to operate on these sorts of
grand scales, but our industry is reliably short-sighted
when it comes to building products that will last, and we
could stand to be inspired by the work being done on the
Clock of the Long Now.

If you start work on a high volume software service, it
doesn't take long before you realize just how fragile they
are. To a layman, Google.com (or any big site) just looks
like any other web page, and they'd expect that it wouldn't
take much to maintained and online. But it's a case where
your eyes and intuition will fail you -- behind the modest
facade, there's a war behind of the scenes of any service
operating on this scale. An army of engineers and
technicians are monitoring a fleet of services, turning
over hardware, discovering problems produced at the long
tail, and fixing bugs.

If that team of maintainers for any service operating at a
similar scale were to leave the building and not come back,
it's a very safe assumption that those services wouldn't
last long without their caretakers. How long they'd last
would vary a lot depending on how rigorous the design of
their infrastructure is, but I'd guess that most wouldn't
last more than a few days by themselves before becoming
severely degraded.

I call this **the walkaway test**: if every maintainer
leaves, how long does the software last operating
autonomously? For the purpose of this test, you can assume
that any third party services in use operate as usual. So
AWS will stay working, but it's normal level of failures
should be expected as for example EC2 nodes are lost or S3
becomes briefly unavailable.

## Tweeting for 10,000 years (#tweeting)

I wanted to write a little experiment to see how long I
could make a simple program last without any intervention
from me. I [built one][perpetual] that's preloaded with a
number of scheduled tweets that will fire on an exponential
scale, with the soonest having gone out just a few minutes
before this article was published, and the furthest aiming
to fire 10,000 years from now.

TODO: Screenshot of tweet.

The tweets are all prefixed with a number like LHI001
(where "LHI" means "long heartbeat interval") so that the
program can check to see which one was the last that was
published.

I'm going to try and hedge off a little bit of criticism
early by saying that this is just meant as a thought
experiment, and it's likelihood of making it to 100 years,
let alone 10,000, aren't good (see [Existential
threats](#threats) below for more). The core idea is to try
and engineer the program to be as resilient as possible to
see how long it'll last.

## Hedging against failure (#hedging)

* Used Go -- shown good API stability
* Used Amazon -- big company that doesn't like to retire
  services
* No persistence -- relies entirely on Twitter's API
* Runs as a self-contained binary -- changes in bootstrap
  and dependencies are unlikely to change how it runs

## Time and scale (#time)

It's a fun idea, but as you may have already surmised, my
program won't be tweeting for 10,000 years. Humans tend to
have a hard time imagining increasing orders of magnitude
(see [scope insensitivity][insensitivity]); we can all
easily to the arithmetic that there are 1,000 ten year
segments in 10,000, but it's difficult to appreciate how
much more time that really is.

Consider that the oldest pyramid, the Pyramid of Djoser at
Saqqara, isn't quite 5,000 years old, which is _ancient_.
As young Cleopatra, and who lived alongside some of
history's other most famous characters like Julius Caesar,
Mark Antony, and Augustus, looked up the huge stone
monuments that were her country's legacy, consider that
they'd been constructed further back in history for her
(she was born 69 BC) than she is back in history for us. We
have a few human artifacts from as far back as 10,000 years
ago, but they mostly amount to fragments of pots.

## Existential threats (#threats)

* My program will not tweet for 10,000 years
* So the question is, what fails first?
    * Application bug
    * Binary incompatibility
    * Amazon:
        * Lambda API compatibility
        * Product retired
        * Billing
    * Twitter:
        * API key or OAuth application
        * API changes
        * Moves to a new pricing model
        * Folds as a company
        * No one home: Twitter becomes the living dead like
          ICQ

## What we can learn from a clock (#learn)

> The basic design principles and requirements for the clock are:[3]
>
> * Longevity: The clock should be accurate even after 10,000 years, and must not contain valuable parts (such as jewels, expensive metals, or special alloys) that might be looted.
> * Maintainability: Future generations should be able to keep the clock working, if necessary, with nothing more advanced than Bronze Age tools and materials.
> * Transparency: The clock should be understandable without stopping or disassembling it; no functionality should be opaque.
> * Evolvability: It should be possible to improve the clock over time.
> * Scalability: To ensure that the final large clock will work properly, smaller prototypes must be built and tested.

[1] Common wisdom is that GraphQL at Facebook is
sequestered to internal APIs only, although the public API
they do offer is graph-like and could fairly be called
proto-GraphQL.

[clock]: https://en.wikipedia.org/wiki/Clock_of_the_Long_Now
[insensitivity]: https://en.wikipedia.org/wiki/Scope_neglect
[longnow]: https://en.wikipedia.org/wiki/Long_Now_Foundation
[perpetual]: https://github.com/brandur/perpetual
